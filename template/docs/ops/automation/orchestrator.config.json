{
  "executor": {
    "command": "node ./scripts/automation/executor-wrapper.mjs --plan-id {plan_id} --plan-file {plan_file} --run-id {run_id} --mode {mode} --session {session} --role {role} --effective-risk-tier {effective_risk_tier} --declared-risk-tier {declared_risk_tier} --stage-index {stage_index} --stage-total {stage_total} --result-path {result_path} --contact-pack-file {contact_pack_file}",
    "provider": "codex",
    "promptTemplate": "Continue plan {plan_id} in {plan_file}. Current role: {role}. Declared risk tier: {declared_risk_tier}. Effective risk tier: {effective_risk_tier}. Execution profile: model={role_model}, reasoning={role_reasoning_effort}, sandbox={role_sandbox_mode}. Primary task contact pack: {contact_pack_file}. Primary runtime policy reference: {runtime_context_file}. Use the contact pack first and expand scope only when a blocker requires targeted evidence. Role instructions: {role_instructions}. For worker role sessions, prioritize concrete implementation edits in source and test files (for example apps/, libs/, packages/, src/, and tests) and then update {plan_file}, {plan_evidence_file}, and {plan_evidence_index_file} to capture progress/evidence. For planner/explorer/reviewer role stages, keep edits scoped to {plan_file}, {plan_evidence_file}, and {plan_evidence_index_file}; avoid scanning unrelated docs unless required for this role stage. Apply the next concrete step for this role. Keep plan/evidence updates concise and net-new only (avoid large pasted excerpts or repeated unchanged checklists). Update the plan document with progress and evidence. Reuse existing evidence files when blocker state is unchanged; update canonical evidence index/readme links instead of creating new timestamped evidence files. Avoid redundant validation reruns: do not repeat the same verification command in consecutive sessions unless relevant files changed or the last run failed. Do not run host-bound validations directly in this executor session (infra/bootstrap, DB migrations, Playwright/E2E/browser tests); treat them as validation.hostRequired work and leave execution to the host-validation lane. ALWAYS write a structured JSON result to ORCH_RESULT_PATH with status (completed|blocked|handoff_required|pending), summary, reason, and numeric contextRemaining. Use status pending (not blocked) only when the same role needs another session in this run after concrete progress. For worker role sessions, do not defer implementation to planner/explorer; if no external blocker exists, apply at least one concrete repository edit before returning pending. For planner/explorer/reviewer role stages, return status completed once role-scoped objectives are done, even when the overall plan stays in-progress for later roles. Planner/explorer must record concrete next implementation steps directly in plan/evidence docs before returning completed. Reserve blocked for external/manual gates orchestration cannot progress automatically. Never exit 0 without writing this payload. If contextRemaining is at/below ORCH_CONTEXT_THRESHOLD and another same-role session is required for concrete progress, return status handoff_required. For planner/explorer/reviewer roles, return status completed when role-scoped objectives are done even when contextRemaining is low. Do not wait for host-required validations to run inside this executor session. If implementation acceptance criteria are complete and the plan is ready for orchestration validation lanes, set top-level Status: completed to trigger validation; otherwise keep top-level Status: in-progress and list remaining implementation work.",
    "providers": {
      "codex": {
        "command": "codex exec --full-auto -c model_reasoning_effort={role_reasoning_effort} -m {role_model} {prompt}"
      },
      "claude": {
        "command": "claude -p --model {role_model} {prompt}"
      }
    },
    "enforceRoleModelSelection": true,
    "handoffExitCode": 75,
    "contextThreshold": 10000,
    "requireResultPayload": true,
    "timeoutSeconds": 1800
  },
  "context": {
    "runtimeContextPath": "docs/generated/agent-runtime-context.md",
    "maxTokens": 1400,
    "contactPacks": {
      "enabled": true,
      "maxPolicyBullets": 10,
      "includeRecentEvidence": true,
      "maxRecentEvidenceItems": 6
    }
  },
  "validation": {
    "always": [],
    "requireAlwaysCommands": true,
    "alwaysExamples": [
      "npm run test:unit"
    ],
    "hostRequired": [],
    "requireHostRequiredCommands": true,
    "hostRequiredExamples": [
      "npm run infra:up",
      "npm run db:migrate",
      "npm run test:e2e"
    ],
    "timeoutSeconds": 1800,
    "host": {
      "mode": "hybrid",
      "timeoutSeconds": 1800,
      "ci": {
        "command": "",
        "timeoutSeconds": 1800
      },
      "local": {
        "command": ""
      }
    }
  },
  "recovery": {
    "retryFailed": true,
    "autoUnblock": true,
    "maxFailedRetries": 3
  },
  "evidence": {
    "compaction": {
      "mode": "compact-index",
      "maxReferences": 25
    },
    "lifecycle": {
      "trackMode": "curated",
      "dedupMode": "strict-upsert",
      "pruneOnComplete": true,
      "keepMaxPerBlocker": 1
    }
  },
  "roleOrchestration": {
    "enabled": true,
    "mode": "risk-adaptive",
    "roleProfiles": {
      "explorer": {
        "model": "gpt-5.3-codex-spark",
        "reasoningEffort": "medium",
        "sandboxMode": "read-only",
        "instructions": "You are a fast codebase explorer. Search files, read code, trace dependencies, and answer scoped questions. You may update active plan/evidence docs for this stage, but do not modify product/source code. Record concrete implementation-ready findings in plan/evidence docs before finishing. Keep the pass bounded and implementation-oriented: if blocker state is unchanged and worker next steps are concrete, record a concise checkpoint and return completed in this session rather than requesting another explorer handoff."
      },
      "reviewer": {
        "model": "gpt-5.3-codex",
        "reasoningEffort": "high",
        "sandboxMode": "read-only",
        "instructions": "Focus on high-priority issues: security vulnerabilities, correctness bugs, race conditions, test flakiness, and performance problems. Prefer targeted checks and avoid rerunning identical validations when no relevant files changed."
      },
      "worker": {
        "model": "gpt-5.3-codex",
        "reasoningEffort": "high",
        "sandboxMode": "full-access",
        "instructions": "You are an execution-focused agent. Implement features, fix bugs, and refactor precisely while following existing patterns. Start with a concrete repository edit as soon as feasible, then continue iteratively. Do not defer implementation work back to planner/explorer when a concrete edit can be made now."
      },
      "planner": {
        "model": "gpt-5.3-codex",
        "reasoningEffort": "high",
        "sandboxMode": "read-only",
        "instructions": "You are an architect agent. Break down tasks into implementation steps, identify dependencies/risks, and output a structured execution plan. Update plan/evidence docs with concrete next-step checklists, and avoid modifying product/source code or running full repository validation commands in this stage."
      }
    },
    "pipelines": {
      "low": [
        "worker"
      ],
      "medium": [
        "planner",
        "worker",
        "reviewer"
      ],
      "high": [
        "planner",
        "explorer",
        "worker",
        "reviewer"
      ]
    },
    "stageBudgetsSeconds": {
      "planner": 300,
      "explorer": 300,
      "reviewer": 420
    },
    "stageReuse": {
      "enabled": true,
      "roles": [
        "planner",
        "explorer"
      ],
      "sameRunOnly": false,
      "maxAgeMinutes": 60,
      "requiresStablePlanHash": true,
      "requiresNoScopeChange": true
    },
    "riskModel": {
      "thresholds": {
        "medium": 3,
        "high": 6
      },
      "weights": {
        "declaredMedium": 2,
        "declaredHigh": 4,
        "dependency": 1,
        "sensitiveTag": 2,
        "sensitivePath": 2,
        "autonomyFull": 1,
        "validationFailure": 2
      },
      "sensitiveTags": [
        "security",
        "auth",
        "authentication",
        "payments",
        "pii",
        "migration",
        "infra"
      ],
      "sensitivePaths": [
        "payments",
        "billing",
        "auth",
        "security",
        "migrations",
        "db",
        "compliance"
      ]
    },
    "approvalGates": {
      "requireSecurityOpsForHigh": true,
      "requireSecurityOpsForMediumIfSensitive": true,
      "securityApprovalMetadataField": "Security-Approval"
    },
    "providers": {
      "codex": {
        "roleProfiles": {},
        "roles": {
          "planner": {
            "command": "codex exec --full-auto -c model_reasoning_effort={role_reasoning_effort} -m {role_model} {prompt}"
          },
          "explorer": {
            "command": "codex exec --full-auto -c model_reasoning_effort={role_reasoning_effort} -m {role_model} {prompt}"
          },
          "worker": {
            "command": "codex exec --full-auto -c model_reasoning_effort={role_reasoning_effort} -m {role_model} {prompt}"
          },
          "reviewer": {
            "command": "codex exec --full-auto -c model_reasoning_effort={role_reasoning_effort} -m {role_model} {prompt}"
          }
        }
      },
      "claude": {
        "roleProfiles": {},
        "roles": {}
      }
    }
  },
  "validationCommands": [],
  "logging": {
    "output": "pretty",
    "failureTailLines": 60,
    "heartbeatSeconds": 12,
    "stallWarnSeconds": 120,
    "touchSummary": true,
    "touchSampleSize": 3,
    "workerFirstTouchDeadlineSeconds": 180,
    "workerNoTouchRetryLimit": 1
  },
  "parallel": {
    "maxPlans": 1,
    "worktreeRoot": "docs/ops/automation/runtime/worktrees",
    "branchPrefix": "orch",
    "baseRef": "HEAD",
    "gitRemote": "origin",
    "workerOutputMode": "pretty",
    "keepWorktrees": false,
    "pushBranches": false,
    "openPullRequests": false,
    "assumeDependencyCompletion": false,
    "pullRequest": {
      "createCommand": "",
      "mergeCommand": ""
    }
  },
  "git": {
    "atomicCommits": true,
    "atomicCommitRoots": {
      "defaults": [],
      "shared": [],
      "allowPlanMetadata": true,
      "enforce": true
    }
  }
}
